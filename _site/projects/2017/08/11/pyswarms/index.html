<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>PySwarms: a particle swarm optimization library in Python</title>
  <meta name="description" content="For the past few weeks, I’ve started an open-source project in Python by building a research toolkit for Particle Swarm Optimization (PSO). PSO is a heuristi...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/projects/2017/08/11/pyswarms/">
  <link rel="alternate" type="application/rss+xml" title="Lj Miranda" href="/feed.xml">
  <link rel="icon" type="image/png" href="/assets/favicon.ico">
  
  
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
   

  

  <!-- Begin Jekyll SEO tag v2.3.0 -->
<title>PySwarms: a particle swarm optimization library in Python | Lj Miranda</title>
<meta property="og:title" content="PySwarms: a particle swarm optimization library in Python" />
<meta name="author" content="LJ MIRANDA" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="For the past few weeks, I’ve started an open-source project in Python by building a research toolkit for Particle Swarm Optimization (PSO). PSO is a heuristic search algorithm that was inspired by the social dynamics of birds and bees. What made me interested in PSO is that it tries to simulate group behavior when faced with a certain objective, something that can also be observed in humans. Furthermore, the standard algorithm is simple, and can be used in a variety of applications. Documentation: https://pyswarms.readthedocs.io/en/latest/ Github Page: https://github.com/ljvmiranda921/pyswarms Inspiration If one is to look at published literature, there is a multitude of variations in the standard PSO algorithm, all of these being applied in different situations. It then becomes hard for researchers to benchmark their results because there’s no unified framework to do it. Hopefully, a standard library should exist for implementing not only the classic PSO algorithms, but also the state-of-the-art variations in literature. In addition, I found some of the current implementations a bit lacking. tisimst’s work, although useful, is not extensible and works only on one type of problem (although I named my project with respect to theirs). On the other hand PyGMO and DEAP, although mature, are more generalized to evolutionary computation algorithms. Features I realized that if I am to build an optimization library, it must have three important features: (1) the user-facing API must be easy-to-use, that is, an optimization can already be done in less than 5-8 lines of code, (2) supporting utilities must be included to assess optimizer performance, and (3) the programming API must be highly-extensible. These three are the guiding principles when I built PySwarms. Easy-to-use optimization tool This feature is highly important especially for users who just wanted a quick-and-easy optimization process. I hope that this can minimize “frustration” in setting up various configurables and the like. For example, if we want to find the minima of a sphere function using global-best PSO, we only need to import the pyswarms.single.GlobalBestPSO class and the built-in pyswarms.utils.functions.single_obj module to do optimization: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx # Set-up hyperparameters options = {&#39;c1&#39;: 0.5, &#39;c2&#39;: 0.3, &#39;w&#39;:0.9} # Call instance of PSO optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=2, options=options) # Perform optimization cost, pos = optimizer.optimize(fx.sphere_func, print_step=100, iters=1000, verbose=2) Excluding the comments and spaces, it only takes five lines to perform optimization. Compare this to DEAP’s implementation. Although in all fairness, DEAP can be seen as a lower-level computational tool than what PySwarms is aspiring to be. More examples can be seen at the documentation. Supporting utilities to assess optimizer performance Enhancements such as support-utilties are very important in assessing swarm behavior and optimizer performance. As of now, a PlotEnvironment class is implemented to perform such tasks. The idea is to pass the optimizer in this environment in order to call various methods such as plot_cost() or plot_particles2D(). The visualization tool is built on top of Matplotlib in order to provide deeper customizability to the plots. However, the default settings are already decent. Consider the same example as above as we pass it in the plot environment: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx from pyswarms.utils.environments import PlotEnvironment # Create optimizer options = {&#39;c1&#39;:0.5, &#39;c2&#39;:0.3, &#39;w&#39;:0.9} optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=3, options=options) # Pass to plot environment plt_env = PlotEnvironment(optimizer, fx.sphere_func, 1000) From this we can call various methods already. If we call plot_cost(), then we can obtain a plot similar to the one below Figure 1: Calling the plot_cost() method generates a cost history line plot. More so, we can even animate swarm movement. Recall that we are using a Global-best PSO algorithm, where each particle compares itself with the best-performing particle in the group. Notice in the figure below how these particles converge on the global-best at position (0,0,0). To generate a 3-d animation, we just need to call the plot_particles3D() method. Figure 2: Particle movement generated by calling the plot_particles3D() method. Highly-extensible API I think that it is important to build an easy to use API for researchers an contributors who wanted to implement their own techniques or add new features. Honestly, this has become a challenge for myself, being new in the open-source field. I’m still iterating my base classes but I’m confident that most of these are now extensible as I’ve imagined. The main idea for this is to inherit from base classes in order to implement new techniques. Most of the development time goes to the base classes, making sure that they are applicable in the most general sense. These include an array of getters, attributes, and abstract methods that I deem universal in most PSO implementations. Thus, if one is to observe the implementations on pyswarms.single.GlobalBestPSO and pyswarms.single.LocalBestPSO, not much redundancy exists between the two. The main idea for implementing an optimizer can be seen in this guide. You can also view the API documentation here. Tutorials I wrote some accompanying tutorials on using PySwarms, most of these include use-cases on where to use Particle Swarm Optimization in some problems, and how PySwarms can make the implementations much easier. They are all in the documentation, but I will list some of them here: Basic Optimization Training a neural network classifier Feature subset selection For Developers If you wish to contribute on PySwarms, simply check the instructions in this link. In case you are interested and found this project nice, please leave a star on GitHub!" />
<meta property="og:description" content="For the past few weeks, I’ve started an open-source project in Python by building a research toolkit for Particle Swarm Optimization (PSO). PSO is a heuristic search algorithm that was inspired by the social dynamics of birds and bees. What made me interested in PSO is that it tries to simulate group behavior when faced with a certain objective, something that can also be observed in humans. Furthermore, the standard algorithm is simple, and can be used in a variety of applications. Documentation: https://pyswarms.readthedocs.io/en/latest/ Github Page: https://github.com/ljvmiranda921/pyswarms Inspiration If one is to look at published literature, there is a multitude of variations in the standard PSO algorithm, all of these being applied in different situations. It then becomes hard for researchers to benchmark their results because there’s no unified framework to do it. Hopefully, a standard library should exist for implementing not only the classic PSO algorithms, but also the state-of-the-art variations in literature. In addition, I found some of the current implementations a bit lacking. tisimst’s work, although useful, is not extensible and works only on one type of problem (although I named my project with respect to theirs). On the other hand PyGMO and DEAP, although mature, are more generalized to evolutionary computation algorithms. Features I realized that if I am to build an optimization library, it must have three important features: (1) the user-facing API must be easy-to-use, that is, an optimization can already be done in less than 5-8 lines of code, (2) supporting utilities must be included to assess optimizer performance, and (3) the programming API must be highly-extensible. These three are the guiding principles when I built PySwarms. Easy-to-use optimization tool This feature is highly important especially for users who just wanted a quick-and-easy optimization process. I hope that this can minimize “frustration” in setting up various configurables and the like. For example, if we want to find the minima of a sphere function using global-best PSO, we only need to import the pyswarms.single.GlobalBestPSO class and the built-in pyswarms.utils.functions.single_obj module to do optimization: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx # Set-up hyperparameters options = {&#39;c1&#39;: 0.5, &#39;c2&#39;: 0.3, &#39;w&#39;:0.9} # Call instance of PSO optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=2, options=options) # Perform optimization cost, pos = optimizer.optimize(fx.sphere_func, print_step=100, iters=1000, verbose=2) Excluding the comments and spaces, it only takes five lines to perform optimization. Compare this to DEAP’s implementation. Although in all fairness, DEAP can be seen as a lower-level computational tool than what PySwarms is aspiring to be. More examples can be seen at the documentation. Supporting utilities to assess optimizer performance Enhancements such as support-utilties are very important in assessing swarm behavior and optimizer performance. As of now, a PlotEnvironment class is implemented to perform such tasks. The idea is to pass the optimizer in this environment in order to call various methods such as plot_cost() or plot_particles2D(). The visualization tool is built on top of Matplotlib in order to provide deeper customizability to the plots. However, the default settings are already decent. Consider the same example as above as we pass it in the plot environment: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx from pyswarms.utils.environments import PlotEnvironment # Create optimizer options = {&#39;c1&#39;:0.5, &#39;c2&#39;:0.3, &#39;w&#39;:0.9} optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=3, options=options) # Pass to plot environment plt_env = PlotEnvironment(optimizer, fx.sphere_func, 1000) From this we can call various methods already. If we call plot_cost(), then we can obtain a plot similar to the one below Figure 1: Calling the plot_cost() method generates a cost history line plot. More so, we can even animate swarm movement. Recall that we are using a Global-best PSO algorithm, where each particle compares itself with the best-performing particle in the group. Notice in the figure below how these particles converge on the global-best at position (0,0,0). To generate a 3-d animation, we just need to call the plot_particles3D() method. Figure 2: Particle movement generated by calling the plot_particles3D() method. Highly-extensible API I think that it is important to build an easy to use API for researchers an contributors who wanted to implement their own techniques or add new features. Honestly, this has become a challenge for myself, being new in the open-source field. I’m still iterating my base classes but I’m confident that most of these are now extensible as I’ve imagined. The main idea for this is to inherit from base classes in order to implement new techniques. Most of the development time goes to the base classes, making sure that they are applicable in the most general sense. These include an array of getters, attributes, and abstract methods that I deem universal in most PSO implementations. Thus, if one is to observe the implementations on pyswarms.single.GlobalBestPSO and pyswarms.single.LocalBestPSO, not much redundancy exists between the two. The main idea for implementing an optimizer can be seen in this guide. You can also view the API documentation here. Tutorials I wrote some accompanying tutorials on using PySwarms, most of these include use-cases on where to use Particle Swarm Optimization in some problems, and how PySwarms can make the implementations much easier. They are all in the documentation, but I will list some of them here: Basic Optimization Training a neural network classifier Feature subset selection For Developers If you wish to contribute on PySwarms, simply check the instructions in this link. In case you are interested and found this project nice, please leave a star on GitHub!" />
<link rel="canonical" href="http://localhost:4000/projects/2017/08/11/pyswarms/" />
<meta property="og:url" content="http://localhost:4000/projects/2017/08/11/pyswarms/" />
<meta property="og:site_name" content="Lj Miranda" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-08-11T00:00:00+09:00" />
<script type="application/ld+json">
{"name":null,"description":"For the past few weeks, I’ve started an open-source project in Python by building a research toolkit for Particle Swarm Optimization (PSO). PSO is a heuristic search algorithm that was inspired by the social dynamics of birds and bees. What made me interested in PSO is that it tries to simulate group behavior when faced with a certain objective, something that can also be observed in humans. Furthermore, the standard algorithm is simple, and can be used in a variety of applications. Documentation: https://pyswarms.readthedocs.io/en/latest/ Github Page: https://github.com/ljvmiranda921/pyswarms Inspiration If one is to look at published literature, there is a multitude of variations in the standard PSO algorithm, all of these being applied in different situations. It then becomes hard for researchers to benchmark their results because there’s no unified framework to do it. Hopefully, a standard library should exist for implementing not only the classic PSO algorithms, but also the state-of-the-art variations in literature. In addition, I found some of the current implementations a bit lacking. tisimst’s work, although useful, is not extensible and works only on one type of problem (although I named my project with respect to theirs). On the other hand PyGMO and DEAP, although mature, are more generalized to evolutionary computation algorithms. Features I realized that if I am to build an optimization library, it must have three important features: (1) the user-facing API must be easy-to-use, that is, an optimization can already be done in less than 5-8 lines of code, (2) supporting utilities must be included to assess optimizer performance, and (3) the programming API must be highly-extensible. These three are the guiding principles when I built PySwarms. Easy-to-use optimization tool This feature is highly important especially for users who just wanted a quick-and-easy optimization process. I hope that this can minimize “frustration” in setting up various configurables and the like. For example, if we want to find the minima of a sphere function using global-best PSO, we only need to import the pyswarms.single.GlobalBestPSO class and the built-in pyswarms.utils.functions.single_obj module to do optimization: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx # Set-up hyperparameters options = {&#39;c1&#39;: 0.5, &#39;c2&#39;: 0.3, &#39;w&#39;:0.9} # Call instance of PSO optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=2, options=options) # Perform optimization cost, pos = optimizer.optimize(fx.sphere_func, print_step=100, iters=1000, verbose=2) Excluding the comments and spaces, it only takes five lines to perform optimization. Compare this to DEAP’s implementation. Although in all fairness, DEAP can be seen as a lower-level computational tool than what PySwarms is aspiring to be. More examples can be seen at the documentation. Supporting utilities to assess optimizer performance Enhancements such as support-utilties are very important in assessing swarm behavior and optimizer performance. As of now, a PlotEnvironment class is implemented to perform such tasks. The idea is to pass the optimizer in this environment in order to call various methods such as plot_cost() or plot_particles2D(). The visualization tool is built on top of Matplotlib in order to provide deeper customizability to the plots. However, the default settings are already decent. Consider the same example as above as we pass it in the plot environment: # Import PySwarms import pyswarms as ps from pyswarms.utils.functions import single_obj as fx from pyswarms.utils.environments import PlotEnvironment # Create optimizer options = {&#39;c1&#39;:0.5, &#39;c2&#39;:0.3, &#39;w&#39;:0.9} optimizer = ps.single.GlobalBestPSO(n_particles=10, dimensions=3, options=options) # Pass to plot environment plt_env = PlotEnvironment(optimizer, fx.sphere_func, 1000) From this we can call various methods already. If we call plot_cost(), then we can obtain a plot similar to the one below Figure 1: Calling the plot_cost() method generates a cost history line plot. More so, we can even animate swarm movement. Recall that we are using a Global-best PSO algorithm, where each particle compares itself with the best-performing particle in the group. Notice in the figure below how these particles converge on the global-best at position (0,0,0). To generate a 3-d animation, we just need to call the plot_particles3D() method. Figure 2: Particle movement generated by calling the plot_particles3D() method. Highly-extensible API I think that it is important to build an easy to use API for researchers an contributors who wanted to implement their own techniques or add new features. Honestly, this has become a challenge for myself, being new in the open-source field. I’m still iterating my base classes but I’m confident that most of these are now extensible as I’ve imagined. The main idea for this is to inherit from base classes in order to implement new techniques. Most of the development time goes to the base classes, making sure that they are applicable in the most general sense. These include an array of getters, attributes, and abstract methods that I deem universal in most PSO implementations. Thus, if one is to observe the implementations on pyswarms.single.GlobalBestPSO and pyswarms.single.LocalBestPSO, not much redundancy exists between the two. The main idea for implementing an optimizer can be seen in this guide. You can also view the API documentation here. Tutorials I wrote some accompanying tutorials on using PySwarms, most of these include use-cases on where to use Particle Swarm Optimization in some problems, and how PySwarms can make the implementations much easier. They are all in the documentation, but I will list some of them here: Basic Optimization Training a neural network classifier Feature subset selection For Developers If you wish to contribute on PySwarms, simply check the instructions in this link. In case you are interested and found this project nice, please leave a star on GitHub!","url":"http://localhost:4000/projects/2017/08/11/pyswarms/","headline":"PySwarms: a particle swarm optimization library in Python","dateModified":"2017-08-11T00:00:00+09:00","datePublished":"2017-08-11T00:00:00+09:00","sameAs":null,"@type":"BlogPosting","author":{"@type":"Person","name":"LJ MIRANDA"},"image":null,"publisher":null,"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/projects/2017/08/11/pyswarms/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    <a class="site-title" href="/">Lj Miranda</a>
  
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/downloads/LMiranda.pdf">CV</a>
            <a class="page-link" href="/research/">Research</a>
            <a class="page-link" href="/projects/">Projects</a>
            <a class="page-link" href="/notebook/">Notebook</a>
        </div>
      </nav>
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">PySwarms: a particle swarm optimization library in Python</h1>
    <p class="post-meta">
      <time datetime="2017-08-11T00:00:00+09:00" itemprop="datePublished">
        
        Aug 11, 2017
      </time>
      
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">LJ MIRANDA</span></span>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>For the past few weeks, I’ve started an open-source project in Python by building a research toolkit
for Particle Swarm Optimization (PSO). PSO is a heuristic search algorithm that was inspired by the
social dynamics of birds and bees. What made me interested in PSO is that it tries to simulate group
behavior when faced with a certain objective, something that can also be observed in humans. Furthermore,
the standard algorithm is simple, and can be used in a variety of applications.</p>

<p><img src="/assets/png/pyswarms/pyswarms-header.png" alt="PySwarms" width="640px" /></p>

<p><a href="https://badge.fury.io/py/pyswarms"><img src="https://badge.fury.io/py/pyswarms.svg" alt="PyPI version" /></a>
<a href="https://travis-ci.org/ljvmiranda921/pyswarms"><img src="https://img.shields.io/travis/ljvmiranda921/pyswarms.svg" alt="Build Status" /></a>
<a href="https://pyswarms.readthedocs.io/en/latest/?badge=latest"><img src="https://readthedocs.org/projects/pyswarms/badge/?version=latest" alt="Documentation Status" /></a>
<a href="https://landscape.io/github/ljvmiranda921/pyswarms/master"><img src="https://landscape.io/github/ljvmiranda921/pyswarms/master/landscape.svg?style=flat" alt="Code Health" /></a>
<a href="https://pyup.io/repos/github/ljvmiranda921/pyswarms/"><img src="https://pyup.io/repos/github/ljvmiranda921/pyswarms/shield.svg" alt="Updates" /></a>
<a href="https://raw.githubusercontent.com/ljvmiranda921/pyswarms/master/LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License" /></a></p>

<ul>
  <li>
    <p><strong>Documentation:</strong> <a href="https://pyswarms.readthedocs.io/en/latest/">https://pyswarms.readthedocs.io/en/latest/</a></p>
  </li>
  <li>
    <p><strong>Github Page:</strong> <a href="https://github.com/ljvmiranda921/pyswarms">https://github.com/ljvmiranda921/pyswarms</a></p>
  </li>
</ul>

<h2 id="inspiration">Inspiration</h2>

<p>If one is to look at published literature, there is a multitude of variations in the standard
PSO algorithm, all of these being applied in different situations. It then becomes hard for researchers
to benchmark their results because there’s no unified framework to do it. Hopefully, a standard library
should exist for implementing not only the classic PSO algorithms, but also the state-of-the-art variations
in literature.</p>

<p>In addition, I found some of the current implementations a bit lacking. <a href="https://github.com/tisimst/pyswarm">tisimst’s</a>
work, although useful, is not extensible and works only on one type of problem (although I named my project
with respect to theirs). On the other hand <a href="http://esa.github.io/pygmo/">PyGMO</a> and <a href="https://github.com/DEAP/deap">DEAP</a>,
although mature, are more generalized to evolutionary computation algorithms.</p>

<h2 id="features">Features</h2>

<p>I realized that if I am to build an optimization library, it must have three important features: (1) the
user-facing API must be easy-to-use, that is, an optimization can already be done in less than 5-8 lines
of code, (2) supporting utilities must be included to assess optimizer performance, and (3) the programming
API must be highly-extensible. These three are the guiding principles when I built PySwarms.</p>

<h3 id="easy-to-use-optimization-tool">Easy-to-use optimization tool</h3>

<p>This feature is highly important especially for users who just wanted a quick-and-easy optimization process.
I hope that this can minimize “frustration” in setting up various configurables and the like. For example,
if we want to find the minima of a sphere function using global-best PSO, we only need to import the
<code class="highlighter-rouge">pyswarms.single.GlobalBestPSO</code> class and the built-in <code class="highlighter-rouge">pyswarms.utils.functions.single_obj</code> module to
do optimization:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Import PySwarms</span>
<span class="kn">import</span> <span class="nn">pyswarms</span> <span class="kn">as</span> <span class="nn">ps</span>
<span class="kn">from</span> <span class="nn">pyswarms.utils.functions</span> <span class="kn">import</span> <span class="n">single_obj</span> <span class="k">as</span> <span class="n">fx</span>

<span class="c"># Set-up hyperparameters</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s">'c1'</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s">'c2'</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="s">'w'</span><span class="p">:</span><span class="mf">0.9</span><span class="p">}</span>
<span class="c"># Call instance of PSO</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">single</span><span class="o">.</span><span class="n">GlobalBestPSO</span><span class="p">(</span><span class="n">n_particles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>
<span class="c"># Perform optimization</span>
<span class="n">cost</span><span class="p">,</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">fx</span><span class="o">.</span><span class="n">sphere_func</span><span class="p">,</span> <span class="n">print_step</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre>
</div>

<p>Excluding the comments and spaces, it only takes five lines to perform optimization. Compare this to
<a href="http://deap.readthedocs.io/en/master/overview.html">DEAP’s implementation</a>. Although in all fairness,
DEAP can be seen as a lower-level computational tool than what PySwarms is aspiring to be.</p>

<p>More examples can be seen at the <a href="https://pyswarms.readthedocs.io/en/latest/examples/usecases.html">documentation</a>.</p>

<h3 id="supporting-utilities-to-assess-optimizer-performance">Supporting utilities to assess optimizer performance</h3>

<p>Enhancements such as support-utilties are very important in assessing swarm behavior and optimizer
performance. As of now, a <code class="highlighter-rouge">PlotEnvironment</code> class is implemented to perform such tasks. The idea is
to pass the optimizer in this environment in order to call various methods such as <code class="highlighter-rouge">plot_cost()</code> or
<code class="highlighter-rouge">plot_particles2D()</code>. The visualization tool is built on top of Matplotlib in order to provide
deeper customizability to the plots.</p>

<p>However, the default settings are already decent. Consider the same example as above as we pass it in
the plot environment:</p>

<div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="c"># Import PySwarms</span>
<span class="kn">import</span> <span class="nn">pyswarms</span> <span class="kn">as</span> <span class="nn">ps</span>
<span class="kn">from</span> <span class="nn">pyswarms.utils.functions</span> <span class="kn">import</span> <span class="n">single_obj</span> <span class="k">as</span> <span class="n">fx</span>
<span class="kn">from</span> <span class="nn">pyswarms.utils.environments</span> <span class="kn">import</span> <span class="n">PlotEnvironment</span>

<span class="c"># Create optimizer</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s">'c1'</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="s">'c2'</span><span class="p">:</span><span class="mf">0.3</span><span class="p">,</span> <span class="s">'w'</span><span class="p">:</span><span class="mf">0.9</span><span class="p">}</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">single</span><span class="o">.</span><span class="n">GlobalBestPSO</span><span class="p">(</span><span class="n">n_particles</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">)</span>

<span class="c"># Pass to plot environment</span>
<span class="n">plt_env</span> <span class="o">=</span> <span class="n">PlotEnvironment</span><span class="p">(</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">fx</span><span class="o">.</span><span class="n">sphere_func</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</code></pre>
</div>

<p>From this we can call various methods already. If we call <code class="highlighter-rouge">plot_cost()</code>, then we can obtain a plot
similar to the one below</p>

<p style="text-align: center;"><img src="/assets/png/pyswarms/output_9_0.png" alt="Cost History" width="560px" /> <br />
<strong>Figure 1:</strong> <em>Calling the <code class="highlighter-rouge">plot_cost()</code> method generates a cost history line plot.</em></p>

<p>More so, we can even animate swarm movement. Recall that we are using a Global-best PSO algorithm,
where each particle compares itself with the best-performing particle in the group. Notice in the
figure below how these particles converge on the global-best at position <code class="highlighter-rouge">(0,0,0)</code>. To generate
a 3-d animation, we just need to call the <code class="highlighter-rouge">plot_particles3D()</code> method.</p>

<p style="text-align: center;"><img src="/assets/png/pyswarms/output_3d.gif" alt="3D particle movement" width="560px" /> <br />
<strong>Figure 2:</strong> <em>Particle movement generated by calling the <code class="highlighter-rouge">plot_particles3D()</code> method.</em></p>

<h3 id="highly-extensible-api">Highly-extensible API</h3>

<p>I think that it is important to build an easy to use API for researchers an contributors who wanted
to implement their own techniques or add new features. Honestly, this has become a challenge for myself,
being new in the open-source field. I’m still iterating my base classes but I’m confident that most of
these are now extensible as I’ve imagined.</p>

<p>The main idea for this is to inherit from base classes in order to implement new techniques. Most of the
development time goes to the base classes, making sure that they are applicable in the most general sense.
These include an array of getters, attributes, and abstract methods that I deem universal in most PSO
implementations. Thus, if one is to observe the implementations on <code class="highlighter-rouge">pyswarms.single.GlobalBestPSO</code> and
<code class="highlighter-rouge">pyswarms.single.LocalBestPSO</code>, not much redundancy exists between the two.</p>

<p>The main idea for implementing an optimizer can be seen in this <a href="https://pyswarms.readthedocs.io/en/latest/contributing.optimizer.html">guide</a>. You can also view the API
documentation <a href="https://pyswarms.readthedocs.io/en/latest/api/pyswarms.html">here</a>.</p>

<h2 id="tutorials">Tutorials</h2>

<p>I wrote some accompanying tutorials on using PySwarms, most of these include use-cases on where to
use Particle Swarm Optimization in some problems, and how PySwarms can make the implementations much
easier. They are all in the documentation, but I will list some of them here:</p>

<ul>
  <li><a href="https://pyswarms.readthedocs.io/en/latest/examples/basic_optimization.html">Basic Optimization</a></li>
  <li><a href="https://pyswarms.readthedocs.io/en/latest/examples/train_neural_network.html">Training a neural network classifier</a></li>
  <li><a href="https://pyswarms.readthedocs.io/en/latest/examples/feature_subset_selection.html">Feature subset selection</a></li>
</ul>

<h2 id="for-developers">For Developers</h2>

<p>If you wish to contribute on PySwarms, simply check the instructions in <a href="https://pyswarms.readthedocs.io/en/latest/contributing.html">this</a> link. In case you are interested and found this project nice, please leave a star on GitHub!</p>

  </div>

  
    

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Lj Miranda</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Lj Miranda
            
            </li>
            
            <li><a href="mailto:ljvmiranda@gmail.com">ljvmiranda@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
          <ul class="social-media-list">
    
    
    
    <li><a href="https://github.com/ljvmiranda921"><svg class="svg-icon"><use xlink:href="/assets/icons.svg#github"></use></svg> <span class="username">Github</span></a></li>
    
    <li><a href="https://www.linkedin.com/in/lesterjamesmiranda"><svg class="svg-icon"><use xlink:href="/assets/icons.svg#linkedin"></use></svg> <span class="username">Linkedin</span></a></li>
    
    
    
    
    <li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/icons.svg#rss"></use></svg> <span>RSS</span></a></li>
</ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Some notes on software development, data science, machine learning, and research.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
